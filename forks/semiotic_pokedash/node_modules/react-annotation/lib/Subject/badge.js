"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = require("../Builder");

// import { event } from "d3-selection"

// export default ({ subjectData = {}, type = {} }, annotation = {}) => {
exports.default = function (_ref) {
  var _ref$radius = _ref.radius,
      radius = _ref$radius === undefined ? 14 : _ref$radius,
      leftRight = _ref.leftRight,
      topBottom = _ref.topBottom,
      text = _ref.text,
      color = _ref.color,
      editMode = _ref.editMode;

  // const typeSettings = type.typeSettings && type.typeSettings.subject

  // if (!subjectData.radius) {
  //   if (typeSettings && typeSettings.radius) {
  //     subjectData.radius = typeSettings.radius
  //   } else {
  //     subjectData.radius = 14
  //   }
  // }
  // if (!subjectData.x) {
  //   if (typeSettings && typeSettings.x) {
  //     subjectData.x = typeSettings.x
  //   }
  // }
  // if (!subjectData.y) {
  //   if (typeSettings && typeSettings.y) {
  //     subjectData.y = typeSettings.y
  //   }
  // }

  var handles = [];
  var components = [];
  // const radius = subjectData.radius
  var innerRadius = radius * 0.7;
  var x = 0;
  var y = 0;

  var notCornerOffset = Math.sqrt(2) * radius;
  var placement = {
    xleftcorner: -radius,
    xrightcorner: radius,
    ytopcorner: -radius,
    ybottomcorner: radius,
    xleft: -notCornerOffset,
    xright: notCornerOffset,
    ytop: -notCornerOffset,
    ybottom: notCornerOffset
  };

  if (leftRight && !topBottom) {
    x = placement["x" + leftRight];
  } else if (topBottom && !leftRight) {
    y = placement["y" + topBottom];
  } else if (leftRight && topBottom) {
    x = placement["x" + leftRight + "corner"];
    y = placement["y" + topBottom + "corner"];
  }

  var transform = "translate(" + x + ", " + y + ")";
  var circlebg = (0, _Builder.arcBuilder)({ className: "subject", data: { radius: radius } });
  circlebg.attrs.transform = transform;
  circlebg.attrs.fill = color;
  circlebg.attrs["stroke-linecap"] = "round";
  circlebg.attrs["stroke-width"] = "3px";

  var circle = (0, _Builder.arcBuilder)({
    className: "subject-ring",
    data: { outerRadius: radius, innerRadius: innerRadius }
  });

  circle.attrs.transform = transform;
  circle.attrs["stroke-width"] = "3px";
  circle.attrs.fill = "white";

  var pointer = void 0;
  if (x && y || !x && !y) {
    pointer = (0, _Builder.lineBuilder)({
      className: "subject-pointer",
      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
    });
  } else if (x || y) {
    var notCornerPointerXY = function notCornerPointerXY(v) {
      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
    };

    pointer = (0, _Builder.lineBuilder)({
      className: "subject-pointer",
      data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
    });
  }

  if (pointer) {
    pointer.attrs.fill = color;
    pointer.attrs["stroke-linecap"] = "round";
    pointer.attrs["stroke-width"] = "3px";
    components.push(pointer);
  }

  if (editMode) {
    var dragBadge = function dragBadge(event) {
      var x = event.x < -radius * 2 ? "left" : event.x > radius * 2 ? "right" : undefined;
      var y = event.y < -radius * 2 ? "top" : event.y > radius * 2 ? "bottom" : undefined;

      // type.redrawSubject()
      return { x: x, y: y };
    };

    var bHandles = {
      x: x * 2,
      y: y * 2,
      drag: dragBadge, //.bind(type),
      type: "dragXY"
    };
    if (!bHandles.x && !bHandles.y) {
      bHandles.y = -radius;
    }

    handles = bHandles; //type.mapHandles([bHandles])
  }

  var textNode = void 0;
  if (text) {
    textNode = {
      type: "text",
      className: "badge-text",
      attrs: {
        fill: "white",
        stroke: "none",
        "font-size": ".7em",
        text: text,
        "text-anchor": "middle",
        dy: ".25em",
        x: x,
        y: y
      }
    };
  }

  components.push(circlebg);
  components.push(circle);
  components.push(textNode);

  return { components: components, handles: handles };
};