"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawEdges = exports.drawNodes = exports.hierarchicalRectNodeGenerator = exports.radialRectNodeGenerator = exports.chordNodeGenerator = exports.sankeyNodeGenerator = exports.wordcloudNodeGenerator = exports.chordEdgeGenerator = exports.circleNodeGenerator = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.topologicalSort = topologicalSort;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _semioticMark = require("semiotic-mark");

var _d3Glyphedge = require("d3-glyphedge");

var _d3Shape = require("d3-shape");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var customEdgeHashD = {
  linearc: function linearc(d) {
    return _d3Glyphedge.d.lineArc(d);
  },
  ribbon: function ribbon(d) {
    return _d3Glyphedge.d.ribbon(d, d.width);
  },
  arrowhead: function arrowhead(d) {
    return _d3Glyphedge.d.arrowHead(d, d.target.nodeSize, d.width, d.width * 1.5);
  },
  halfarrow: function halfarrow(d) {
    return _d3Glyphedge.d.halfArrow(d, d.target.nodeSize, d.width, d.width * 1.5);
  },
  nail: function nail(d) {
    return _d3Glyphedge.d.nail(d, d.source.nodeSize);
  },
  comet: function comet(d) {
    return _d3Glyphedge.d.comet(d, d.target.nodeSize);
  },
  taffy: function taffy(d) {
    return _d3Glyphedge.d.taffy(d, d.source.nodeSize / 2, d.target.nodeSize / 2, (d.source.nodeSize + d.target.nodeSize) / 4);
  }
};

var circleNodeGenerator = exports.circleNodeGenerator = function circleNodeGenerator(_ref) {
  var d = _ref.d,
      i = _ref.i,
      styleFn = _ref.styleFn,
      renderMode = _ref.renderMode,
      key = _ref.key,
      className = _ref.className,
      transform = _ref.transform,
      baseMarkProps = _ref.baseMarkProps;

  //this is repetitious
  return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
    key: key,
    transform: transform,
    markType: "rect",
    width: d.nodeSize * 2,
    height: d.nodeSize * 2,
    ry: d.nodeSize * 2,
    rx: d.nodeSize * 2,
    x: -d.nodeSize,
    y: -d.nodeSize,
    style: styleFn(d, i),
    renderMode: renderMode ? renderMode(d, i) : undefined,
    className: className
  }));
};

var chordEdgeGenerator = exports.chordEdgeGenerator = function chordEdgeGenerator(size) {
  return function (_ref2) {
    var d = _ref2.d,
        i = _ref2.i,
        styleFn = _ref2.styleFn,
        renderMode = _ref2.renderMode,
        key = _ref2.key,
        className = _ref2.className,
        baseMarkProps = _ref2.baseMarkProps;
    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d, i) : undefined,
      key: key,
      className: className,
      simpleInterpolate: true,
      transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")",
      markType: "path",
      d: d.d,
      style: styleFn(d, i)
    }));
  };
};

var wordcloudNodeGenerator = exports.wordcloudNodeGenerator = function wordcloudNodeGenerator(_ref3) {
  var d = _ref3.d,
      i = _ref3.i,
      styleFn = _ref3.styleFn,
      key = _ref3.key,
      className = _ref3.className,
      transform = _ref3.transform;

  var textStyle = styleFn(d, i);
  textStyle.fontSize = d.fontSize + "px";
  textStyle.fontWeight = d.fontWeight;
  textStyle.textAnchor = "middle";
  var textTransform = void 0,
      textY = void 0,
      textX = void 0;
  textTransform = "scale(" + d.scale + ")";

  if (!d.rotate) {
    textY = d.textHeight / 4;
    textTransform = "scale(" + d.scale + ")";
  } else {
    textTransform = "rotate(90) scale(" + d.scale + ")";
    textY = d.textHeight / 4;
  }

  return _react2.default.createElement(
    "g",
    { key: key, transform: transform },
    _react2.default.createElement(
      "text",
      {
        style: textStyle,
        y: textY,
        x: textX,
        transform: textTransform,
        className: className + " wordcloud"
      },
      d._NWFText
    )
  );
};

var sankeyNodeGenerator = exports.sankeyNodeGenerator = function sankeyNodeGenerator(_ref4) {
  var d = _ref4.d,
      i = _ref4.i,
      styleFn = _ref4.styleFn,
      renderMode = _ref4.renderMode,
      key = _ref4.key,
      className = _ref4.className,
      transform = _ref4.transform,
      baseMarkProps = _ref4.baseMarkProps;
  return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
    renderMode: renderMode ? renderMode(d, i) : undefined,
    key: key,
    className: className,
    transform: transform,
    markType: "rect",
    height: d.height,
    width: d.width,
    x: -d.width / 2,
    y: -d.height / 2,
    rx: 0,
    ry: 0,
    style: styleFn(d)
  }));
};

var chordNodeGenerator = exports.chordNodeGenerator = function chordNodeGenerator(size) {
  return function (_ref5) {
    var d = _ref5.d,
        i = _ref5.i,
        styleFn = _ref5.styleFn,
        renderMode = _ref5.renderMode,
        key = _ref5.key,
        className = _ref5.className,
        baseMarkProps = _ref5.baseMarkProps;
    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d, i) : undefined,
      key: key,
      className: className,
      transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")",
      markType: "path",
      d: d.d,
      style: styleFn(d, i)
    }));
  };
};

var radialRectNodeGenerator = exports.radialRectNodeGenerator = function radialRectNodeGenerator(size, center) {
  var radialArc = (0, _d3Shape.arc)();
  return function (_ref6) {
    var d = _ref6.d,
        i = _ref6.i,
        styleFn = _ref6.styleFn,
        renderMode = _ref6.renderMode,
        key = _ref6.key,
        className = _ref6.className,
        baseMarkProps = _ref6.baseMarkProps;

    radialArc.innerRadius(d.y0 / 2).outerRadius(d.y1 / 2);

    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      key: key,
      transform: "translate(" + center + ")",
      markType: "path",
      d: radialArc({
        startAngle: d.x0 / size[0] * Math.PI * 2,
        endAngle: d.x1 / size[0] * Math.PI * 2
      }),
      style: styleFn(d, i),
      renderMode: renderMode ? renderMode(d, i) : undefined,
      className: className
    }));
  };
};

var hierarchicalRectNodeGenerator = exports.hierarchicalRectNodeGenerator = function hierarchicalRectNodeGenerator(_ref7) {
  var d = _ref7.d,
      i = _ref7.i,
      styleFn = _ref7.styleFn,
      renderMode = _ref7.renderMode,
      key = _ref7.key,
      className = _ref7.className,
      baseMarkProps = _ref7.baseMarkProps;

  //this is repetitious
  return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
    key: key,
    transform: "translate(0,0)",
    markType: "rect",
    width: d.x1 - d.x0,
    height: d.y1 - d.y0,
    x: d.x0,
    y: d.y0,
    rx: 0,
    ry: 0,
    style: styleFn(d, i),
    renderMode: renderMode ? renderMode(d, i) : undefined,
    className: className
  }));
};

var genericLineGenerator = function genericLineGenerator(d) {
  return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
};

var drawNodes = exports.drawNodes = function drawNodes(_ref8) {
  var data = _ref8.data,
      renderKeyFn = _ref8.renderKeyFn,
      customMark = _ref8.customMark,
      styleFn = _ref8.styleFn,
      classFn = _ref8.classFn,
      renderMode = _ref8.renderMode,
      canvasDrawing = _ref8.canvasDrawing,
      canvasRenderFn = _ref8.canvasRenderFn,
      baseMarkProps = _ref8.baseMarkProps;

  var markGenerator = customMark || circleNodeGenerator;
  var renderedData = [];

  if (customMark && canvasRenderFn) {
    console.error("canvas rendering currently only supports generic circle nodes based on nodeSize");
  }

  data.forEach(function (d, i) {
    if (canvasRenderFn && canvasRenderFn(d, i) === true) {
      var canvasNode = {
        baseClass: "frame-piece",
        tx: d.x,
        ty: d.y,
        d: d,
        i: i,
        markProps: { markType: "circle", r: d.nodeSize },
        styleFn: styleFn,
        renderFn: renderMode,
        classFn: classFn
      };
      canvasDrawing.push(canvasNode);
    } else {
      renderedData.push(markGenerator({
        d: d,
        i: i,
        renderKeyFn: renderKeyFn,
        styleFn: styleFn,
        classFn: classFn,
        renderMode: renderMode,
        key: renderKeyFn ? renderKeyFn(d, i) : d.id || "node-" + i,
        className: "node " + classFn(d, i),
        transform: "translate(" + d.x + "," + d.y + ")",
        baseMarkProps: baseMarkProps
      }));
    }
  });
  return renderedData;
};

var drawEdges = exports.drawEdges = function drawEdges(_ref9) {
  var data = _ref9.data,
      renderKeyFn = _ref9.renderKeyFn,
      customMark = _ref9.customMark,
      styleFn = _ref9.styleFn,
      classFn = _ref9.classFn,
      renderMode = _ref9.renderMode,
      canvasRenderFn = _ref9.canvasRenderFn,
      canvasDrawing = _ref9.canvasDrawing,
      type = _ref9.type,
      baseMarkProps = _ref9.baseMarkProps;

  var dGenerator = genericLineGenerator;
  var renderedData = [];
  if (customMark) {
    data.forEach(function (d, i) {
      renderedData.push(customMark({
        d: d,
        i: i,
        renderKeyFn: renderKeyFn,
        styleFn: styleFn,
        classFn: classFn,
        renderMode: renderMode,
        key: renderKeyFn ? renderKeyFn(d, i) : "edge-" + i,
        className: classFn(d, i) + " edge",
        transform: "translate(" + d.x + "," + d.y + ")",
        baseMarkProps: baseMarkProps
      }));
    });
  } else {
    if (type) {
      if (typeof type === "function") {
        dGenerator = type;
      } else if (customEdgeHashD[type]) {
        dGenerator = function dGenerator(d) {
          return customEdgeHashD[type](d);
        };
      }
    }
    data.forEach(function (d, i) {
      if (canvasRenderFn && canvasRenderFn(d, i) === true) {
        var canvasNode = {
          baseClass: "frame-piece",
          tx: d.x,
          ty: d.y,
          d: d,
          i: i,
          markProps: { markType: "path", d: dGenerator(d) },
          styleFn: styleFn,
          renderFn: renderMode,
          classFn: classFn
        };
        canvasDrawing.push(canvasNode);
      } else {
        renderedData.push(_react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
          key: renderKeyFn ? renderKeyFn(d, i) : "edge-" + i,
          markType: "path",
          renderMode: renderMode ? renderMode(d, i) : undefined,
          className: classFn(d) + " edge",
          d: dGenerator(d),
          style: styleFn(d, i)
        })));
      }
    });
  }

  return renderedData;
};

function topologicalSort(nodesArray, edgesArray) {
  // adapted from https://simplapi.wordpress.com/2015/08/19/detect-graph-cycle-in-javascript/
  var nodes = [];
  var nodeHash = {};
  edgesArray.forEach(function (edge) {
    if (!edge.source.id || !edge.target.id) {
      return false;
    }
    if (!nodeHash[edge.source.id]) {
      nodeHash[edge.source.id] = { _id: edge.source.id, links: [] };
      nodes.push(nodeHash[edge.source.id]);
    }
    if (!nodeHash[edge.target.id]) {
      nodeHash[edge.target.id] = { _id: edge.target.id, links: [] };
      nodes.push(nodeHash[edge.target.id]);
    }
    nodeHash[edge.source.id].links.push(edge.target.id);
  });

  // Test if a node got any icoming edge
  function hasIncomingEdge(list, node) {
    for (var i = 0, l = list.length; i < l; ++i) {
      if (list[i].links.indexOf(node._id) !== -1) {
        return true;
      }
    }
    return false;
  }

  // Kahn Algorithm
  var L = [],
      S = nodes.filter(function (node) {
    return !hasIncomingEdge(nodes, node);
  });

  var n = null;

  while (S.length) {
    // Remove a node n from S
    n = S.pop();
    // Add n to tail of L
    L.push(n);

    var i = n.links.length;
    while (i--) {
      // Getting the node associated to the current stored id in links
      var m = nodes[nodes.map(function (d) {
        return d._id;
      }).indexOf(n.links[i])];

      // Remove edge e from the graph
      n.links.pop();

      if (!hasIncomingEdge(nodes, m)) {
        S.push(m);
      }
    }
  }

  // If any of them still got links, there is cycle somewhere
  var nodeWithEdge = nodes.find(function (node) {
    return node.links.length !== 0;
  });

  return nodeWithEdge ? null : L;
}