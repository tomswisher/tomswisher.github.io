"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgRectEncloseRule = exports.svgEncloseRule = exports.svgReactAnnotationRule = exports.svgNodeRule = exports.htmlFrameHoverRule = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _Annotation = require("../Annotation");

var _Annotation2 = _interopRequireDefault(_Annotation);

var _reactAnnotation = require("react-annotation");

var _d3Hierarchy = require("d3-hierarchy");

var _baseRules = require("./baseRules");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var htmlFrameHoverRule = exports.htmlFrameHoverRule = function htmlFrameHoverRule(_ref) {
  var d = _ref.d,
      i = _ref.i,
      tooltipContent = _ref.tooltipContent;

  var content = d.edge ? _react2.default.createElement(
    "div",
    { className: "tooltip-content" },
    _react2.default.createElement(
      "p",
      { key: "html-annotation-content-1" },
      d.edge.source.id,
      " to ",
      d.edge.target.id
    )
  ) : _react2.default.createElement(
    "div",
    { className: "tooltip-content" },
    _react2.default.createElement(
      "p",
      { key: "html-annotation-content-1" },
      d.id
    ),
    _react2.default.createElement(
      "p",
      { key: "html-annotation-content-2" },
      "Degree: ",
      d.degree
    )
  );

  if (d.type === "frame-hover" && tooltipContent) {
    content = tooltipContent(d);
  }

  return _react2.default.createElement(
    "div",
    {
      key: "xylabel" + i,
      className: "annotation annotation-network-label " + (d.className || ""),
      style: {
        position: "absolute",
        top: d.y + "px",
        left: d.x + "px"
      }
    },
    content
  );
};

var svgNodeRule = exports.svgNodeRule = function svgNodeRule(_ref2) {
  var d = _ref2.d,
      i = _ref2.i,
      projectedNodes = _ref2.projectedNodes,
      nodeIDAccessor = _ref2.nodeIDAccessor,
      nodeSizeAccessor = _ref2.nodeSizeAccessor;

  var selectedNode = d.x && d.y ? d : projectedNodes.find(function (p) {
    return nodeIDAccessor(p) === d.id;
  });
  if (!selectedNode) {
    return null;
  }
  var noteData = _extends({
    dx: d.dx || -25,
    dy: d.dy || -25,
    x: selectedNode.x,
    y: selectedNode.y,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: _reactAnnotation.AnnotationCalloutCircle,
    subject: {
      radius: d.radius || selectedNode.radius || nodeSizeAccessor(d)
    }
  });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgReactAnnotationRule = exports.svgReactAnnotationRule = function svgReactAnnotationRule(_ref3) {
  var d = _ref3.d,
      i = _ref3.i,
      projectedNodes = _ref3.projectedNodes,
      nodeIDAccessor = _ref3.nodeIDAccessor;

  var selectedNode = d.x && d.y ? d : projectedNodes.find(function (p) {
    return nodeIDAccessor(p) === d.id;
  });
  if (!selectedNode) {
    return null;
  }
  var noteData = _extends({
    dx: 0,
    dy: 0,
    x: selectedNode.x,
    y: selectedNode.y,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, { type: typeof d.type === "function" ? d.type : undefined });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgEncloseRule = exports.svgEncloseRule = function svgEncloseRule(_ref4) {
  var d = _ref4.d,
      projectedNodes = _ref4.projectedNodes,
      nodeIDAccessor = _ref4.nodeIDAccessor,
      nodeSizeAccessor = _ref4.nodeSizeAccessor;

  var selectedNodes = projectedNodes.filter(function (p) {
    return d.ids.indexOf(nodeIDAccessor(p)) !== -1;
  });
  if (selectedNodes.length === 0) {
    return null;
  }
  var circle = (0, _d3Hierarchy.packEnclose)(selectedNodes.map(function (p) {
    return { x: p.x, y: p.y, r: nodeSizeAccessor(p) };
  }));
  return (0, _baseRules.circleEnclosure)({ circle: circle, d: d });
};

var svgRectEncloseRule = exports.svgRectEncloseRule = function svgRectEncloseRule(_ref5) {
  var d = _ref5.d,
      i = _ref5.i,
      projectedNodes = _ref5.projectedNodes,
      nodeIDAccessor = _ref5.nodeIDAccessor,
      nodeSizeAccessor = _ref5.nodeSizeAccessor;

  var selectedNodes = projectedNodes.filter(function (p) {
    return d.ids.indexOf(nodeIDAccessor(p)) !== -1;
  });
  if (selectedNodes.length === 0) {
    return null;
  }

  var bboxNodes = selectedNodes.map(function (p) {
    var nodeSize = nodeSizeAccessor(p);
    return {
      x0: p.x0 === undefined ? p.x - nodeSize : p.x0,
      x1: p.x1 === undefined ? p.x + nodeSize : p.x1,
      y0: p.y0 === undefined ? p.y - nodeSize : p.y0,
      y1: p.y1 === undefined ? p.y + nodeSize : p.y1
    };
  });
  return (0, _baseRules.rectangleEnclosure)({ bboxNodes: bboxNodes, d: d, i: i });
};